# 代码规范文档

此文档定义了本项目中编写代码的标准和要求，所有代码贡献都应遵循这些规范。

## 命名规范

### 类命名
- **类名**: 使用名词或名词短语，PascalCase格式，准确描述类的职责
- **示例**: `SpreadMaintain`, `TradingEngine`, `OrderManager`
- **检查**: 类名是否表达了其中心目的？

### 方法命名
- **方法名**: 使用动词或动词短语，清晰表达动作意图
- **示例**: `calculate_order_side()`, `validate_symbol_compliance()`
- **禁止**: 不要使用布尔值参数，使用枚举或策略模式替代

### 函数命名
- **函数名**: 使用动词开头，snake_case格式
- **长度限制**: 单个函数不超过50行，if/else/while内只应有一行代码（调用另一个函数）
- **参数限制**: 参数不超过3个，避免布尔值参数
- **复杂参数**: 多个参数应封装成类或数据结构
- **输出参数**: 不要输出参数，创建新对象或修改所在对象状态

### 变量命名
- **变量名**: 使用描述性名词，snake_case格式
- **命名清晰**: 名称应与抽象层级相符，无歧义
- **作用范围**: 较大作用范围选用较长名称
- **副作用说明**: 名称要说明副作用

### 常量命名
- **常量名**: 使用UPPER_SNAKE_CASE格式
- **示例**: `MAX_RETRY_COUNT`, `DEFAULT_TIMEOUT`, `SPREAD_THRESHOLD`

## 函数设计原则

### 单一职责与抽象层级
- **指令与询问分离**: 函数要么执行操作，要么查询数据，不能同时做两件事
- **单一抽象层级**: 函数内的所有操作应在同一抽象层级
- **函数分解**: 复杂逻辑分解为多个小函数

### 参数设计
- **参数封装**: 超过3个参数时创建参数类
- **避免None**: 不要返回None，不要传递None，使用明确的异常
- **类型安全**: 使用Optional类型明确可空性

### 错误处理
- **错误分离**: 将错误处理和主要逻辑流程分离
- **异常处理**: 创建具体的异常类而非通用异常
- **错误恢复**: 提供重试机制和降级方案

### 代码复用
- **DRY原则**: 不要重复自己，消除重复代码
- **死代码**: 删除不执行的代码和未调用的函数
- **注释代码**: 删除注释掉的代码，不要保留

## 类设计原则

### SOLID原则
- **单一职责原则(SRP)**: 每个类只有一个职责，只有一个变化原因
- **开闭原则(OCP)**: 对扩展开放，对修改关闭
- **里氏替换原则(LSP)**: 派生类必须能够替换基类
- **接口隔离原则(ISP)**: 使用多个专门接口而非单一总接口
- **依赖倒置原则(DIP)**: 高层模块不依赖低层模块，都依赖抽象

### 类设计要点
- **类大小**: 保持类短小精悍，100-200行为宜
- **内聚性**: 类的方法应操作相同的实体变量，高内聚
- **封装性**: 最小化成员可访问性，避免暴露内部实现
- **命名清晰**: 类名应准确描述其职责和用途

### 类质量检查清单
- [ ] 类是否有单一中心目的？
- [ ] 类名是否恰当表达其中心目的？
- [ ] 类接口是否呈现一致抽象？
- [ ] 类是否足够封装，可作为黑盒使用？
- [ ] 类是否避免了无关信息？
- [ ] 类是否需要进一步分解为更小组件？
- [ ] 类数据成员是否只有7个或更少？
- [ ] 是否最小化了与其他类的协作？

### 数据封装与信息隐藏
- **德墨忒尔法则**: 模块不应了解它所操作对象的内部情况
- **信息隐藏**: 隐藏实现细节，暴露必要接口
- **数据验证**: 所有外部数据输入必须验证

## 注释规范

### 注释原则
- **自说明代码**: 优先通过清晰的代码表达意图，而非注释
- **必要注释**: 仅用于解释复杂业务逻辑和代码意图
- **解释意图**: 解释代码背后的意图，而非代码本身
- **代码外信息**: 避免代码外的无关信息

### 废弃代码处理
- **废弃注释**: 及时删除无关或过时的注释
- **注释代码**: 删除注释掉的代码，不要保留
- **TODO注释**: 使用 `# TODO: 具体描述` 格式
- **FIXME注释**: 使用 `# FIXME: 具体描述` 格式

### 文档字符串
- **函数注释**: 使用Google风格文档字符串
- **复杂逻辑**: 关键算法需要添加注释说明意图

## 异常处理规范

### 异常设计原则
- **不返回None**: 使用明确的异常而非None表示错误
- **不传递None**: 参数验证后立即处理，避免None传播
- **具体异常**: 创建具体的异常类而非通用异常
- **异常分离**: 将异常处理与业务逻辑分离

### 异常处理模式
- **集中处理**: 在适当层级集中处理异常
- **错误恢复**: 提供重试机制和降级方案
- **用户友好**: 提供清晰的错误信息和解决建议

## 测试规范

### 测试设计原则
- **测试质量**: 测试代码的整洁度要求与生产代码一致
- **单一概念**: 每个测试函数只测试一个概念
- **独立性**: 测试应独立运行，不依赖其他测试状态
- **可扩展性**: 测试是代码可扩展的保证

### 测试类型与要求
- **单元测试**: 每个函数至少一个测试用例
- **集成测试**: 每个模块至少一个集成测试
- **参数化测试**: 相同行为不同输入使用参数化测试
- **模拟测试**: 使用mock/stub替代外部依赖
- **测试覆盖率**: 保持80%以上代码覆盖率

### 测试最佳实践
- **设计一致性**: 测试设计、整洁度需和生产代码有一致要求
- **测试独立**: 每个测试应独立于其他测试运行
- **参数化**: 对于测试相同行为但输入不同的情况，使用参数化测试
- **模拟依赖**: 当测试涉及外部系统或昂贵资源时，使用模拟和存根

## 并发编程规范

### 异步代码
- **异常处理**: 使用try/except处理协程异常
- **超时设置**: 所有网络调用必须有超时保护
- **资源清理**: 确保finally块中释放资源

### 线程安全与并发
- **共享状态**: 避免共享可变状态
- **锁机制**: 必要时使用asyncio.Lock
- **原子操作**: 优先使用原子操作而非锁
- **依赖注入**: 使用DI实现控制反转，减少耦合

## 代码组织与结构

### 代码布局
- **垂直距离**: 变量定义靠近使用位置
- **函数顺序**: 调用者在上，被调用者在下
- **相关代码**: 相关函数和变量放在一起
- **代码清晰度**: 优先使用肯定条件而非否定条件

### 设计模式应用
- **多态替代**: 使用多态替代复杂if-else
- **接口设计**: 保持接口紧凑，避免信息过多
- **依赖管理**: 高层模块依赖抽象而非具体实现

## 日志规范

### 日志级别
- **DEBUG**: 详细调试信息，开发环境使用
- **INFO**: 重要业务流程节点
- **WARNING**: 预期外但可恢复情况
- **ERROR**: 错误情况，需要关注
- **CRITICAL**: 系统级错误，需要立即处理

### 日志格式与内容
```python
# 良好示例 - 结构化日志
logger.info(f"成功下单: symbol={symbol}, side={side}, volume={volume}, price={price}")

# 避免示例 - 信息不足
logger.info("下单成功")  # 缺少关键信息
```

## 数据库规范

### MongoDB使用
- **索引设计**: 为查询字段创建适当索引
- **数据模型**: 使用一致的字段命名规范
- **批量操作**: 优先使用批量插入和更新
- **连接管理**: 使用连接池管理数据库连接

### Redis使用
- **键命名**: 使用冒号分隔的层次结构，如 `trading:orders:{symbol}`
- **过期时间**: 为临时数据设置TTL
- **内存优化**: 避免存储大对象，使用压缩
- **数据一致性**: 使用事务保证操作原子性

## 安全规范

### 敏感信息处理
- **API密钥**: 从不硬编码在代码中，使用环境变量
- **数据库连接**: 使用配置文件而非硬编码
- **日志脱敏**: 敏感信息必须进行脱敏处理
- **输入验证**: 所有外部输入必须验证类型和边界

### 安全最佳实践
- **SQL注入防护**: 使用参数化查询
- **类型安全**: 运行时类型验证和边界检查
- **配置分离**: 敏感配置与代码分离

## 代码审查清单

### 提交前检查
- [ ] 代码符合PEP 8规范
- [ ] 所有函数都有类型注解
- [ ] 添加了适当的错误处理
- [ ] 更新了相关测试用例
- [ ] 文档已同步更新
- [ ] 敏感信息已脱敏处理
- [ ] 删除了未使用的代码和注释
- [ ] 函数长度不超过50行
- [ ] 类大小保持在合理范围

### 代码审查关注点
- **可读性**: 代码是否易于理解
- **可维护性**: 是否易于修改和扩展
- **性能**: 是否存在性能瓶颈
- **安全性**: 是否存在安全隐患
- **测试**: 是否有足够的测试覆盖
- **设计**: 是否遵循设计原则和模式

## 项目特定约定

### 业务逻辑规范
- **价格精度**: 使用Decimal处理价格，避免浮点精度问题
- **时间处理**: 统一使用毫秒时间戳
- **货币单位**: 统一使用基础货币单位，避免混淆
- **数据精度**: 金融计算保持足够精度，避免舍入误差

### 配置管理
- **环境区分**: 开发、测试、生产环境配置分离
- **动态配置**: 支持运行时配置更新
- **配置验证**: 启动时验证配置有效性
- **版本控制**: 重要配置变更需要版本管理

### 监控和告警
- **关键指标**: 每个策略定义关键业务指标
- **异常告警**: 异常情况及时告警
- **性能监控**: 监控关键路径性能指标
- **日志追踪**: 完整的请求链路追踪

## 常用动词参考

### 数据操作类
- **fetch**: 从外部获取数据（API、数据库）
- **retrieve**: 从存储中检索数据
- **load**: 加载数据或资源
- **read**: 读取文件或数据内容
- **query**: 查询数据库或集合
- **find**: 在集合中查找项

### 数据创建类
- **create**: 创建新对象或数据
- **build**: 构建复杂结构或对象
- **generate**: 生成数据或内容
- **initialize**: 初始化对象状态
- **compose**: 组合多个部分

### 数据处理类
- **calculate**: 执行数学计算
- **compute**: 计算结果
- **process**: 处理数据流程
- **transform**: 转换数据格式
- **parse**: 解析输入数据
- **validate**: 验证数据有效性

### 数据存储类
- **save**: 保存数据到存储
- **store**: 存储数据到指定位置
- **archive**: 归档历史数据
- **persist**: 持久化数据保存

### 控制执行类
- **execute**: 执行命令或操作
- **run**: 运行过程或程序
- **start/stop**: 启动或停止进程
- **trigger**: 触发事件或动作
- **manage**: 管理资源或状态

## 反模式警示清单

### 绝对禁止的反模式
- ❌ **不要创建新模式**: 当现有模式有效时，不要创建新的设计模式
- ❌ **不要跳过验证**: 不能因为"应该能工作"就跳过输入验证
- ❌ **不要忽略失败测试**: 必须修复失败的测试，不能忽略
- ❌ **不要在异步上下文中使用同步函数**: 避免阻塞事件循环
- ❌ **不要硬编码配置值**: 所有可配置值都应放入配置文件
- ❌ **不要捕获所有异常**: 要捕获具体的异常类型，避免通配符捕获

### 常见陷阱
- **过度工程**: 不要为了可能的需求而过度设计
- **过早优化**: 先确保正确性，再考虑性能优化
- **魔法数字**: 避免在代码中使用未命名的常量
- **全局状态**: 避免使用全局变量和单例模式
- **深层继承**: 避免过深的继承层次，优先考虑组合
- **循环依赖**: 避免模块间的循环依赖

## 抽象数据类型检查清单

### 抽象层面检查
- [ ] 是否将类视为抽象数据类型？
- [ ] 类接口是否呈现一致的抽象？
- [ ] 类接口是否让人一眼就知道如何使用？
- [ ] 类服务是否足够完整，无需操作内部数据？

### 封装性检查
- [ ] 是否最小化了类成员的可访问性？
- [ ] 类是否避免了公开其成员数据？
- [ ] 类是否尽可能隐藏了内部实现细节？
- [ ] 类是否不依赖于其他类的具体实现？

### 继承设计检查
- [ ] 继承是否只用于建立"is-a"关系？
- [ ] 派生类是否遵循了里氏替换原则？
- [ ] 通用接口是否放在继承树尽可能高的地方？
- [ ] 继承树是否保持浅层？